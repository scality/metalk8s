// /!\ WARNING :  THIS FILE IS AUTOGENERATED FROM A KUBERNETES CUSTOM RESOURCE DEFINITION FILE. DO NOT CHANGE IT, use crd-client-generator-ts to update it.
import { CustomObjectsApi } from '@kubernetes/client-node/dist/gen/api/customObjectsApi';
export type Result<T> = T | { error: any };

export type V1alpha1Volume = {
  apiVersion?: string;
  kind?: string;
  metadata?: {};
  spec?: {
    mode?: 'Filesystem' | 'Block';
    nodeName: string;
    rawBlockDevice?: { devicePath: string };
    sparseLoopDevice?: { size: number | string };
    storageClassName: string;
    template?: {
      metadata?: {};
      spec?: {
        accessModes?: Array<string>;
        awsElasticBlockStore?: {
          fsType?: string;
          partition?: number;
          readOnly?: boolean;
          volumeID: string;
        };
        azureDisk?: {
          cachingMode?: string;
          diskName: string;
          diskURI: string;
          fsType?: string;
          kind?: string;
          readOnly?: boolean;
        };
        azureFile?: {
          readOnly?: boolean;
          secretName: string;
          secretNamespace?: string;
          shareName: string;
        };
        capacity?: {};
        cephfs?: {
          monitors: Array<string>;
          path?: string;
          readOnly?: boolean;
          secretFile?: string;
          secretRef?: { name?: string; namespace?: string };
          user?: string;
        };
        cinder?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: { name?: string; namespace?: string };
          volumeID: string;
        };
        claimRef?: {
          apiVersion?: string;
          fieldPath?: string;
          kind?: string;
          name?: string;
          namespace?: string;
          resourceVersion?: string;
          uid?: string;
        };
        csi?: {
          controllerExpandSecretRef?: { name?: string; namespace?: string };
          controllerPublishSecretRef?: { name?: string; namespace?: string };
          driver: string;
          fsType?: string;
          nodePublishSecretRef?: { name?: string; namespace?: string };
          nodeStageSecretRef?: { name?: string; namespace?: string };
          readOnly?: boolean;
          volumeAttributes?: {};
          volumeHandle: string;
        };
        fc?: {
          fsType?: string;
          lun?: number;
          readOnly?: boolean;
          targetWWNs?: Array<string>;
          wwids?: Array<string>;
        };
        flexVolume?: {
          driver: string;
          fsType?: string;
          options?: {};
          readOnly?: boolean;
          secretRef?: { name?: string; namespace?: string };
        };
        flocker?: { datasetName?: string; datasetUUID?: string };
        gcePersistentDisk?: {
          fsType?: string;
          partition?: number;
          pdName: string;
          readOnly?: boolean;
        };
        glusterfs?: {
          endpoints: string;
          endpointsNamespace?: string;
          path: string;
          readOnly?: boolean;
        };
        hostPath?: { path: string; type?: string };
        iscsi?: {
          chapAuthDiscovery?: boolean;
          chapAuthSession?: boolean;
          fsType?: string;
          initiatorName?: string;
          iqn: string;
          iscsiInterface?: string;
          lun: number;
          portals?: Array<string>;
          readOnly?: boolean;
          secretRef?: { name?: string; namespace?: string };
          targetPortal: string;
        };
        local?: { fsType?: string; path: string };
        mountOptions?: Array<string>;
        nfs?: { path: string; readOnly?: boolean; server: string };
        nodeAffinity?: {
          required?: {
            nodeSelectorTerms: Array<{
              matchExpressions?: Array<{
                key: string;
                operator: string;
                values?: Array<string>;
              }>;
              matchFields?: Array<{
                key: string;
                operator: string;
                values?: Array<string>;
              }>;
            }>;
          };
        };
        persistentVolumeReclaimPolicy?: string;
        photonPersistentDisk?: { fsType?: string; pdID: string };
        portworxVolume?: {
          fsType?: string;
          readOnly?: boolean;
          volumeID: string;
        };
        quobyte?: {
          group?: string;
          readOnly?: boolean;
          registry: string;
          tenant?: string;
          user?: string;
          volume: string;
        };
        rbd?: {
          fsType?: string;
          image: string;
          keyring?: string;
          monitors: Array<string>;
          pool?: string;
          readOnly?: boolean;
          secretRef?: { name?: string; namespace?: string };
          user?: string;
        };
        scaleIO?: {
          fsType?: string;
          gateway: string;
          protectionDomain?: string;
          readOnly?: boolean;
          secretRef: { name?: string; namespace?: string };
          sslEnabled?: boolean;
          storageMode?: string;
          storagePool?: string;
          system: string;
          volumeName?: string;
        };
        storageClassName?: string;
        storageos?: {
          fsType?: string;
          readOnly?: boolean;
          secretRef?: {
            apiVersion?: string;
            fieldPath?: string;
            kind?: string;
            name?: string;
            namespace?: string;
            resourceVersion?: string;
            uid?: string;
          };
          volumeName?: string;
          volumeNamespace?: string;
        };
        volumeMode?: string;
        vsphereVolume?: {
          fsType?: string;
          storagePolicyID?: string;
          storagePolicyName?: string;
          volumePath: string;
        };
      };
    };
  };
  status?: {
    conditions?: Array<{
      lastTransitionTime?: string;
      lastUpdateTime?: string;
      message?: string;
      reason?:
        | 'Pending'
        | 'Terminating'
        | 'InternalError'
        | 'CreationError'
        | 'DestructionError'
        | 'UnavailableError';
      status: 'True' | 'False' | 'Unknown';
      type: 'Ready';
    }>;
    deviceName?: string;
    job?: string;
  };
};
export type V1alpha1VolumeList = {
  body: { items: V1alpha1Volume[] };
};

export class V1alpha1VolumeClient {
  constructor(private customObjects: CustomObjectsApi) {}
  async getV1alpha1VolumeList(
    namespace: string,
  ): Promise<Result<V1alpha1VolumeList>> {
    try {
      return await this.customObjects.listNamespacedCustomObject(
        'storage.metalk8s.scality.com',
        'v1alpha1',
        namespace,
        'volumes',
      );
    } catch (error) {
      return { error };
    }
  }

  async getV1alpha1Volume(
    namespace: string,
    V1alpha1VolumeName: string,
  ): Promise<Result<V1alpha1Volume>> {
    try {
      return await this.customObjects.getNamespacedCustomObject(
        'storage.metalk8s.scality.com',
        'v1alpha1',
        namespace,
        'volumes',
        V1alpha1VolumeName,
      );
    } catch (error) {
      return { error };
    }
  }

  async deleteV1alpha1Volume(namespace: string, V1alpha1VolumeName: string) {
    try {
      return await this.customObjects.deleteNamespacedCustomObject(
        'storage.metalk8s.scality.com',
        'v1alpha1',
        namespace,
        'volumes',
        V1alpha1VolumeName,
        {},
      );
    } catch (error) {
      return { error };
    }
  }

  async createV1alpha1Volume(
    namespace: string,
    body: V1alpha1Volume,
  ): Promise<Result<V1alpha1Volume>> {
    try {
      return await this.customObjects.createNamespacedCustomObject(
        'storage.metalk8s.scality.com',
        'v1alpha1',
        namespace,
        'volumes',
        body,
      );
    } catch (error) {
      return { error };
    }
  }

  async patchV1alpha1Volume(
    namespace: string,
    body: Partial<V1alpha1Volume>,
  ): Promise<Result<V1alpha1Volume>> {
    try {
      return await this.customObjects.patchNamespacedCustomObject(
        'storage.metalk8s.scality.com',
        'v1alpha1',
        namespace,
        'volumes',
        body,
      );
    } catch (error) {
      return { error };
    }
  }
}
